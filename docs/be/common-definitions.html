---
layout: documentation
---

<!--
 This document is synchronized with Bazel releases.
 To edit, submit changes to the Bazel source code.
-->

<!-- Generated by //src/main/java/com/google/devtools/build/docgen:build-encyclopedia.zip -->

<h1>Common definitions</h1>

<p>This section defines various terms and concepts that are common to
many functions or build rules below.
</p>

<div class="toc">
  <h1>Contents</h1>
  <ul>
    <li><a href="#borne-shell-tokenization">Borne shell tokenization</a></li>
    <li><a href="#label-expansion">Label Expansion</a></li>
    <li><a href="#common-attributes">Attributes common to all build rules</a></li>
    <li><a href="#common-attributes-tests">Attributes common to all test rules (*_test)</a></li>
    <li><a href="#common-attributes-binaries">Attributes common to all binary rules (*_binary)</a></li>
    <li><a href="#configurable-attributes">Configurable attributes</a></li>
    <li><a href="#implicit-outputs">Implicit output targets</a></li>
  </ul>
</div>
<h2 id='sh-tokenization'>Bourne shell tokenization</h2>
<p>
  Certain string attributes of some rules are split into multiple
  words according to the tokenization rules of the Bourne shell:
  unquoted spaces delimit separate words, and single- and
  double-quotes characters and backslashes are used to prevent
  tokenization.
</p>
<p>
  Those attributes that are subject to this tokenization are
  explicitly indicated as such in their definitions in this document.
</p>
<p>
  Attributes subject to "Make" variable expansion and Bourne shell
  tokenization are typically used for passing arbitrary options to
  compilers and other tools. Examples of such attributes are
  <code>cc_library.copts</code> and <code>java_library.javacopts</code>.
  Together these substitutions allow a
  single string variable to expand into a configuration-specific list
  of option words.
</p>

<h2 id='label-expansion'>Label expansion</h2>
<p>
  Some string attributes of a very few rules are subject to label
  expansion: if those strings contain a valid label as a
  substring, such as <code>//mypkg:target</code>, and that label is a
  declared prerequisite of the current rule, it is expanded into the
  pathname of the file represented by the target <code>//mypkg:target</code>.
</p>

<p>
  Example attributes include <code>genrule.cmd</code> and
  <code>cc_binary.linkopts</code>.  The details may vary significantly in
  each case, over such issues as: whether relative labels are
  expanded; how labels that expand to multiple files are
  treated, etc.  Consult the rule attribute documentation for
  specifics.
</p>

<h2 id="common-attributes">Attributes common to all build rules</h2>


<p>This section describes attributes that are common to all build rules.<br/>
Please note that it is an error to list the same label twice in a list of
labels attribute.
</p>

  <table class="table table-condensed table-bordered table-params">
    <colgroup>
      <col class="col-param" />
      <col class="param-description" />
    </colgroup>
    <thead>
      <tr>
        <th>Attribute</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
        <td id="common.data"><code>data</code></td>
        <td><p><code>List of <a href="build-ref.html#labels">labels</a>; optional</code></p>

<p>
The list of files needed by this rule at runtime.
</p>

<p>
Targets named in the <code>data</code> attribute will appear in
the <code>*.runfiles</code> area of this rule, if it has one.  This
may include data files needed by a binary or library, or other
programs needed by it.  See the
<a href="build-ref.html#data">data dependencies</a> section for more
information about how to depend on and use data files.
</p>

<p>
Almost all rules permit a <code>data</code> attribute, but where
this attribute is not allowed, this fact is documented under the
specific rule.
</p>
</td>
      </tr>
        <tr>
        <td id="common.deprecation"><code>deprecation</code></td>
        <td><p><code>String; optional</code></p>

<p>
An explanatory warning message associated with this rule.
Typically this is used to notify users that a rule has become obsolete,
or has become superseded by another rule, is private to a package, or is
perhaps considered harmful for some reason. It is a good idea to include
some reference (like a webpage, a bug number or example migration CLs) so
that one can easily find out what changes are required to avoid the message.
If there is a new target that can be used as a drop in replacement, it is a
good idea to just migrate all users of the old target.
</p>

<p>
This attribute has no effect on the way things are built, but it
may affect a build tool's diagnostic output.  The build tool issues a
warning when a rule with a <code>deprecation</code> attribute is
depended upon by another rule.
</p>

<p>
Intra-package dependencies are exempt from this warning, so that,
for example, building the tests of a deprecated rule does not
encounter a warning.
</p>

<p>
If a deprecated rule depends on another deprecated rule, no warning
message is issued.
</p>

<p>
Once people have stopped using it, the package can be removed or marked as
<a href="#common.obsolete"><code>obsolete</code></a>.
</p>
</td>
      </tr>
        <tr>
        <td id="common.deps"><code>deps</code></td>
        <td>
<p><code>List of <a href="build-ref.html#labels">labels</a>; optional</code></p>

<p>
A list of dependencies of this rule.
</p>

<p>
The precise semantics of what it means for this rule to depend on
another using <code>deps</code> are specific to the kind of this rule,
and the rule-specific documentation below goes into more detail.
At a minimum, though, the targets named via <code>deps</code> will
appear in the <code>*.runfiles</code> area of this rule, if it has
one.
</p>

<p>
Most often, a <code>deps</code> dependency is used to allow one
module to use symbols defined in another module written in the
same programming language and separately compiled.  Cross-language
dependencies are also permitted in many cases: for example,
a <code>java_library</code> rule may depend on C++ code in
a <code>cc_library</code> rule, by declaring the latter in
the <code>deps</code> attribute.  See the definition
of <a href="build-ref.html#deps">dependencies</a> for more
information.
</p>

<p>
Almost all rules permit a <code>deps</code> attribute, but where
this attribute is not allowed, this fact is documented under the
specific rule.
</p>
</td>
      </tr>
        <tr>
        <td id="common.distribs"><code>distribs</code></td>
        <td><p><code>List of strings; optional</code></p>

<p>
A list of distribution-method strings to be used for this particular build rule.
Overrides the <code>BUILD</code>-file scope defaults defined by the
<a href="#distribs"><code>distribs()</code></a> directive.
</p>
</td>
      </tr>
        <tr>
        <td id="common.features"><code>features</code></td>
        <td><p><code>List of <i>features</i>. Default is the empty list.</code></p>

<p><i>Features</i> on a rule modify the <i>features</i> currently enabled on
the <a href="#package">package</a> level via the <i>features</i> attribute.<br/>
For example, if the features ['a', 'b'] are enabled on the package level,
and a rule <i>features</i> attribute contains ['-a', 'c'], the features
enabled for the rule will be 'b' and 'c'.
</p>
</td>
      </tr>
        <tr>
        <td id="common.licenses"><code>licenses</code></td>
        <td><p><code>List of strings; optional</code></p>

<p>
A list of license-type strings to be used for this particular build rule.
Overrides the <code>BUILD</code>-file scope defaults defined by the
<a href="#licenses"><code>licenses()</code></a> directive.
</p>
</td>
      </tr>
        <tr>
        <td id="common.tags"><code>tags</code></td>
        <td><p><code>List of arbitrary text tags.  Tags may be any valid string; default is the
empty list.</code></p>

<p>
<i>Tags</i> can be used on any rule; but <i>tags</i> are most useful
on test and <code>test_suite</code> rules.  Tags on non-test rules
are only useful to humans and/or external programs.
<i>Tags</i> are generally used to annotate a test's role in your debug
and release process.  Typically, tags are most useful for C++ and
Python tests, which
lack any runtime annotation ability.  The use of tags and size elements
gives flexibility in assembling suites of tests based around codebase
check-in policy.
</p>

<p>
A few tags have special meaning to the build tool, such as
indicating that a particular test cannot be run remotely, for
example. Consult
the <a href='bazel-user-manual.html#tags_keywords'>Bazel
documentation</a> for details.
</p>
</td>
      </tr>
        <tr>
        <td id="common.testonly"><code>testonly</code></td>
        <td><p><code>Boolean; optional; default 0 except as noted</code></p>

<p>
If 1, only testonly targets (such as tests) can depend on this target.
</p>

<p>
Equivalently, a rule that is not <code>testonly</code> is not allowed to
depend on any rule that is <code>testonly</code>.
</p>

<p>
Tests (<code>*_test</code> rules)
and test suites (<a href="#test_suite">test_suite</a> rules)
are <code>testonly</code> by default.
</p>

<p>
By virtue of
<a href="#package.default_testonly"><code>default_testonly</code></a>,
targets under <code>javatests</code> are <code>testonly</code> by default.
</p>

<p>
This attribute is intended to mean that the target should not be
contained in binaries that are released to production.
</p>

<p>
Because testonly is enforced at build time, not run time, and propagates
virally through the dependency tree, it should be applied judiciously. For
example, stubs and fakes that
are useful for unit tests may also be useful for integration tests
involving the same binaries that will be released to production, and
therefore should probably not be marked testonly. Conversely, rules that
are dangerous to even link in, perhaps because they unconditionally
override normal behavior, should definitely be marked testonly.
</p>
</td>
      </tr>
        <tr>
        <td id="common.visibility"><code>visibility</code></td>
        <td><p><code>List of <a href="build-ref.html#labels">labels</a>; optional;
default <a href="#package">default_visibility</a> from
<a href="#package">package</a> if specified, else private</code></p>

<p>
The <code>visibility</code> attribute on a rule controls whether
the rule can be used by other packages. Rules are always visible to
other rules declared in the same package.
</p>

<p>There are five forms (and one temporary form) a visibility label can take:
<ul>
<li><code>["//visibility:public"]</code>: Anyone can use this rule.</li>
<li><code>["//visibility:private"]</code>: Only rules in this package
can use this rule.  Rules in <code>javatests/foo/bar</code>
can always use rules in <code>java/foo/bar</code>.
</li>
<li><code>["//some/package:__pkg__", "//other/package:__pkg__"]</code>:
Only rules in <code>some/package</code> and <code>other/package</code>
(defined in <code>some/package/BUILD</code> and
<code>other/package/BUILD</code>) have access to this rule. Note that
sub-packages do not have access to the rule; for example,
<code>//some/package/foo:bar</code> or
<code>//other/package/testing:bla</code> wouldn't have access.
<code>__pkg__</code> is a special target and must be used verbatim.
It represents all of the rules in the package.
</li>
<li><code>["//project:__subpackages__", "//other:__subpackages__"]</code>:
Only rules in packages <code>project</code> or <code>other</code> or
in one of their sub-packages have access to this rule. For example,
<code>//project:rule</code>, <code>//project/library:lib</code> or
<code>//other/testing/internal:munge</code> are allowed to depend on
this rule (but not <code>//independent:evil</code>)
</li>
<li><code>["//some/package:my_package_group"]</code>:
A <a href="#package_group">package group</a> is
a named set of package names. Package groups can also grant access rights
to entire subtrees, e.g.<code>//myproj/...</code>.
</li>

</ul>
<p>The visibility specifications of

<code>//visibility:public</code> and <code>//visibility:private</code>
can not be combined with any other visibility specifications.
A visibility specification may contain a combination of package labels
(i.e. <code>//foo:__pkg__</code>) and <code>package_group</code>s.</p>
<p>If a rule does not specify the visibility attribute,
the <code><a href="#package">default_visibility</a></code>
attribute of the <code><a href="#package">package</a></code>
statement in the BUILD file containing the rule is used
(except <a href="#exports_files">exports_files</a>).</p>
<p>If the default visibility for the package is not specified,
the rule is private.</p>
<p><b>Example</b>:</p>
<p>
File <code>//frobber/bin/BUILD</code>:
</p>
<pre class="code">
# This rule is visible to everyone
cc_binary(
    name = "executable",
    visibility = ["//visibility:public"],
    deps = [":library"],
)

# This rule is visible only to rules declared in the same package
cc_library(
    name = "library",
    visibility = ["//visibility:private"],
)

# This rule is visible to rules in package //object and //noun
cc_library(
    name = "subject",
    visibility = [
        "//noun:__pkg__",
        "//object:__pkg__",
    ],
)

# See package group "//frobber:friends" (below) for who can access this rule.
cc_library(
    name = thingy,
    visibility = ["//frobber:friends"],
)
</pre>
<p>
File <code>//frobber/BUILD</code>:
</p>
<pre class="code">
# This is the package group declaration to which rule //frobber/bin:thingy refers.
#
# Our friends are packages //frobber, //fribber and any subpackage of //fribber.
package_group(
    name = "friends",
    packages = [
        "//fribber/...",
        "//frobber",
    ],
)
</pre>
</td>
      </tr>
      </tbody>
  </table>

<h2 id="common-attributes-tests">Attributes common to all test rules (*_test)</h2>

<p>This section describes attributes that are common to all test rules.</p>

  <table class="table table-condensed table-bordered table-params">
    <colgroup>
      <col class="col-param" />
      <col class="param-description" />
    </colgroup>
    <thead>
      <tr>
        <th>Attribute</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
        <td id="test.args"><code>args</code></td>
        <td><p><code>List of strings; optional; subject to
<a href="#location">$(location)</a> and
<a href="#make_variables">"Make variable"</a> substitution, and
<a href="#sh-tokenization">Bourne shell tokenization</a></code></p>

<p>Add these arguments to the <code>--test_arg</code>
when executed by <code>bazel test</code>.</p>

<p>
These arguments are passed before the <code>--test_arg</code> values
specified on the <code>bazel test</code> command line.
</p>
</td>
      </tr>
        <tr>
        <td id="test.size"><code>size</code></td>
        <td><p><code>String "enormous", "large" "medium" or "small",
default is "medium"; optional</code></p>

<p>How "heavy" the test is.</p>

<p>A classification of the test's "heaviness": how much time/resources
it needs to run.</p>

<p>Unittests are considered "small", integration tests "medium", and
end-to-end tests "large" or "enormous". Bazel uses the size only
to determine a default timeout.</p>
</td>
      </tr>
        <tr>
        <td id="test.timeout"><code>timeout</code></td>
        <td><p><code>String "eternal", "long", "moderate", or "short"
with the default derived from a test's size attribute)</code></p>

<p>
How long the test is normally expected to run before returning.
</p>

<p>
While a test's size attribute controls resource estimation, a test's
timeout may be set independently.  If not explicitly specified, the
timeout is based on the test's size (with "small" &rArr; "short",
"medium" &rArr; "moderate", etc...). By default, "short" means 1 minute,
"moderate" 5 minutes, and "long" 15 minutes (this can be overridden with
--test_timeout, e.g. for running under certain configurations which are
known to be slow).
</p>
</td>
      </tr>
        <tr>
        <td id="test.flaky"><code>flaky</code></td>
        <td><p><code>Boolean; optional</code></p>

<p>
Marks test as flaky.
</p>

<p>
If set, executes the test up to 3 times before being declared as failed.
By default this attribute is set to 0 and test is considered to be stable.
Note, that use of this attribute is generally discouraged - we do prefer
all tests to be stable.
</p>
</td>
      </tr>
        <tr>
        <td id="test.shard_count"><code>shard_count</code></td>
        <td><p>Non-negative integer less than or equal to 50;
optional</p>

<p>Specifies the number of parallel shards
to use to run the test.</p>

<p>This value will override any heuristics used to determine the number of
parallel shards with which to run the test. Note that for some test
rules, this parameter may be required to enable sharding
in the first place. Also see <code>--test_sharding_strategy</code>.</p>

<p>Sharding requires the test runner to support the test sharding protocol.
If it does not, then it will most likely run every test in every shard, which
is not what you want.</p>
</td>
      </tr>
        <tr>
        <td id="test.local"><code>local</code></td>
        <td><p><code>Boolean; optional</code></p>

<p>Forces the test to be run locally, without sandboxing.</p>

<p>By default this attribute is set to 0 and the default testing strategy is
used. This is equivalent to providing "local" as a tag
(<code>tags=["local"]</code>).</p>
</td>
      </tr>
      </tbody>
  </table>

<h2 id="common-attributes-binaries">Attributes common to all binary rules (*_binary)</h2>

<p>This section describes attributes that are common to all binary rules.</p>

  <table class="table table-condensed table-bordered table-params">
    <colgroup>
      <col class="col-param" />
      <col class="param-description" />
    </colgroup>
    <thead>
      <tr>
        <th>Attribute</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
        <td id="binary.args"><code>args</code></td>
        <td><p>
<code>List of strings; optional; subject to
<a href="#location">$(location)</a> and
<a href="#make_variables">"Make variable"</a> substitution, and
<a href="#sh-tokenization">Bourne shell tokenization</a></code>
</p>

<p>
Command line arguments that bazel will pass to the target. These arguments are
passed before the ones that are specified on the <code>bazel run</code>
command line.
</p>

<p>
Most binary rules permit an <code>args</code> attribute, but where
this attribute is not allowed, this fact is documented under the
specific rule.
</p>
</td>
      </tr>
        <tr>
        <td id="binary.output_licenses"><code>output_licenses</code></td>
        <td><p><code>List of strings; optional</code></p>

<p>
The licenses of the output files that this binary generates.
</p>

<p>
Describes the licenses of the output of the binary generated by
the rule. When a binary is referenced in a host attribute (for
example, the <code>tools</code> attribute of
a <code>genrule</code>), this license declaration is used rather
than the union of the licenses of its transitive closure. This
argument is useful when a binary is used as a tool during the
build of a rule, and it is not desirable for its license to leak
into the license of that rule. If this attribute is missing, the
license computation proceeds as if the host dependency was a
regular dependency.
</p>

<p>
(For more about the distinction between host and target
configurations,
see <a href="bazel-user-manual.html#configurations">Build
configurations</a> in the Bazel manual.)</p>

<p>
<em class="harmful">WARNING: in some cases (specifically, in
genrules) the build tool cannot guarantee that the binary
referenced by this attribute is actually used as a tool, and is
not, for example, copied to the output. In these cases, it is the
responsibility of the user to make sure that this is
true.</em>
</p>
</td>
      </tr>
      </tbody>
  </table>

<h2 id="configurable-attributes">Configurable attributes</h2>

<p>
  Most rule attributes can be "configured" so that their values can
  depend on the command-line flags passed to Bazel. This can be used,
  for example, to declare platform-dependent <code>srcs</code> or custom
  compiler flags depending on the
  <a href="bazel-user-manual.html#flag--compilation_mode">compilation
  mode</a>. This feature is very close in spirit to
  <a href="#cc_library.abi_deps">abi_deps</a>, except that it's not
  limited to <code>cc_*</code> rules and the <code>deps</code> attribute.
</p>

</p>

<h2 id="implicit-outputs">Implicit output targets</h2>

<p>When you define a build rule in a BUILD file, you are explicitly
  declaring a new, named rule target in a package.  Many build rule
  functions also <i>implicitly</i> entail one or more output file
  targets, whose contents and meaning are rule-specific.

  For example, when you explicitly declare a
  <code>java_binary(name='foo', ...)</code> rule, you are also
  <i>implicitly</i> declaring an output file
  target <code>foo_deploy.jar</code> as a member of the same package.
  (This particular target is a self-contained Java archive suitable
  for deployment.)
</p>

<p>
  Implicit output targets are first-class members of the global
  target graph.  Just like other targets, they are built on demand,
  either when specified in the top-level built command, or when they
  are necessary prerequisites for other build targets.  They can be
  referenced as dependencies in BUILD files, and can be observed in
  the output of analysis tools such as <code>bazel query</code>.
</p>

<p>
  For each kind of build rule, the rule's documentation contains a
  special section detailing the names and contents of any implicit
  outputs entailed by a declaration of that kind of rule.
</p>

<p>
  An important but somewhat subtle distinction between the
  two namespaces used by the build system:
  <a href="build-ref.html#labels">labels</a> identify <em>targets</em>,
  which may be rules or files, and file targets may be divided into
  either source (or input) file targets and derived (or output) file
  targets.  These are the things you can mention in BUILD files,
  build from the command-line, or examine using <code>bazel query</code>;
  this is the <em>target namespace</em>.  Each file target corresponds
  to one actual file on disk (the "file system namespace"); each rule
  target may correspond to zero, one or more actual files on disk.
  There may be files on disk that have no corresponding target; for
  example, <code>.o</code> object files produced during C++ compilation
  cannot be referenced from within BUILD files or from the command line.
  In this way, the build tool may hide certain implementation details of
  how it does its job. This is explained more fully in
  the <a href="build-ref.html">BUILD Concept Reference</a>.
</p>

<!-- Generated footer -->
