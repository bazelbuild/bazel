# Copyright 2025 The Bazel Authors. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
All build variables we create for various `CppCompileAction`s
"""

load(":common/cc/cc_helper_internal.bzl", "extensions")

_cc_internal = _builtins.internal.cc_internal

# deliberately short name for less clutter while using in this file, we can have
# a different symbol with a more descriptive name if we ever export this
_VARS = struct(
    # Variable for the path to the source file being compiled.
    SOURCE_FILE = "source_file",
    # Variable for all flags coming from copt rule attribute, and from --copt,
    # --cxxopt, or --conlyopt options.
    USER_COMPILE_FLAGS = "user_compile_flags",
    # Variable for the path to the compilation output file.
    OUTPUT_FILE = "output_file",
    # Variable for the dependency file path
    DEPENDENCY_FILE = "dependency_file",
    # Variable for the serialized diagnostics file path
    SERIALIZED_DIAGNOSTICS_FILE = "serialized_diagnostics_file",
    # Variable for the module file name.
    MODULE_NAME = "module_name",
    # Variable for the module map file name.
    MODULE_MAP_FILE = "module_map_file",
    # Variable for the dependent module map file name.
    DEPENDENT_MODULE_MAP_FILES = "dependent_module_map_files",
    # Variable for the gcov coverage file path.
    GCOV_GCNO_FILE = "gcov_gcno_file",
    # Variable for the minimized LTO indexing bitcode file, used by the LTO
    # indexing action. This file was generated by CppCompile actions. For
    # efficiency, it contains minimal information that is required by the LTO
    # indexing action.
    LTO_INDEXING_BITCODE_FILE = "lto_indexing_bitcode_file",
    # Variable for the LTO index file, used by the LTO backend action. This file
    # was generated by the LTO indexing action.
    THINLTO_INDEX = "thinlto_index",
    # Variable for the bitcode file that is input to LTO backend.
    THINLTO_INPUT_BITCODE_FILE = "thinlto_input_bitcode_file",
    # Variable for the object file that is output by LTO backend.
    THINLTO_OUTPUT_OBJECT_FILE = "thinlto_output_object_file",
    # Variable marking fission is used.
    IS_USING_FISSION = "is_using_fission",
    # Variable for the per object debug info file.
    PER_OBJECT_DEBUG_INFO_FILE = "per_object_debug_info_file",
    # Variable present when the output is compiled as position independent.
    PIC = "pic",
)

# buildifier: disable=function-docstring
def setup_common_compile_build_variables(
        *,
        cc_compilation_context,
        cc_toolchain,
        cpp_configuration,
        fdo_context,
        feature_configuration,
        variables_extension):
    return _cc_internal.setup_common_compile_build_variables(
        cc_compilation_context = cc_compilation_context,
        cc_toolchain = cc_toolchain,
        cpp_configuration = cpp_configuration,
        fdo_context = fdo_context,
        feature_configuration = feature_configuration,
        variables_extension = variables_extension,
    )

# Note: this method is side-effect free, callers should add fdo inputs to
# cc_compile_action_builder themselves
def get_specific_compile_build_variables(
        feature_configuration,
        use_pic,
        source_file = None,
        output_file = None,
        dotd_file = None,
        diagnostics_file = None,
        gcno_file = None,
        dwo_file = None,
        lto_indexing_file = None,
        thinlto_index = None,
        thinlto_bitcode_file = None,
        thinlto_output_object_file = None,
        using_fission = False,
        code_coverage_enabled = False,
        cpp_module_map = None,
        direct_module_maps = [],
        user_compile_flags = [],
        additional_build_variables = {},
        fdo_build_variables = {}):
    """Creates a CcToolchainVariables instance

    Args:
        feature_configuration: (FeatureConfiguration)
        use_pic: (bool)
        source_file: (File)
        output_file: (File)
        dotd_file: (File)
        diagnostics_file: (File)
        gcno_file: (File)
        dwo_file: (File)
        lto_indexing_file: (File)
        thinlto_index: (File)
        thinlto_bitcode_file: (File)
        thinlto_output_object_file: (File)
        using_fission: (bool)
        code_coverage_enabled: (bool)
        cpp_module_map: (File)
        direct_module_maps: (list[File])
        user_compile_flags: (list[str])
        additional_build_variables: (dict{str,str})
        fdo_build_variables: (dict{str,str})

    Returns:
        (Variables)
    """
    result = {}

    if feature_configuration.is_enabled("module_maps") and cpp_module_map:
        result[_VARS.MODULE_NAME] = cpp_module_map.name()
        result[_VARS.MODULE_MAP_FILE] = cpp_module_map.file()
        result[_VARS.DEPENDENT_MODULE_MAP_FILES] = depset(direct_module_maps)

    result[_VARS.USER_COMPILE_FLAGS] = _cc_internal.intern_string_sequence_variable_value(user_compile_flags)
    if source_file:
        result[_VARS.SOURCE_FILE] = source_file
    if output_file:
        result[_VARS.OUTPUT_FILE] = output_file

    # Set dependency_file to enable <object>.d file generation.
    if dotd_file:
        result[_VARS.DEPENDENCY_FILE] = dotd_file

    # Set diagnostics_file to enable <object>.dia file generation.
    if diagnostics_file:
        result[_VARS.SERIALIZED_DIAGNOSTICS_FILE] = diagnostics_file

    if gcno_file:
        result[_VARS.GCOV_GCNO_FILE] = gcno_file
    elif code_coverage_enabled:
        # TODO: Blaze currently uses `gcov_gcno_file` to detect if code coverage
        # is enabled. It should use a different signal.
        result[_VARS.GCOV_GCNO_FILE] = ""

    if dwo_file:
        result[_VARS.PER_OBJECT_DEBUG_INFO_FILE] = dwo_file
    if using_fission:
        result[_VARS.IS_USING_FISSION] = ""
    if lto_indexing_file:
        result[_VARS.LTO_INDEXING_BITCODE_FILE] = lto_indexing_file
    if thinlto_index:
        result[_VARS.THINLTO_INDEX] = thinlto_index
    if thinlto_bitcode_file:
        result[_VARS.THINLTO_INPUT_BITCODE_FILE] = thinlto_bitcode_file
    if thinlto_output_object_file:
        result[_VARS.THINLTO_OUTPUT_OBJECT_FILE] = thinlto_output_object_file
    if use_pic:
        result[_VARS.PIC] = ""
    result = result | additional_build_variables
    result = result | fdo_build_variables
    return _cc_internal.cc_toolchain_variables(vars = result)

_SOURCE_TYPES_FOR_CXXOPTS = set(
    extensions.CC_SOURCE +
    extensions.CC_HEADER +
    extensions.CLIF_INPUT_PROTO +
    extensions.CPP_MODULE_MAP +
    extensions.OBJCPP_SOURCE,
)

# buildifier: disable=function-docstring
def get_copts(
        language,
        cpp_configuration,
        source_file,
        conlyopts,
        copts,
        cxxopts,
        label):
    extension = "." + source_file.extension if source_file.extension else ""
    result = []
    result.extend(_copts_from_options(language, cpp_configuration, extension))
    result.extend(copts)
    if extension in extensions.C_SOURCE:
        result.extend(conlyopts)
    if extension in _SOURCE_TYPES_FOR_CXXOPTS:
        result.extend(cxxopts)
    if label:
        result.extend(_cc_internal.per_file_copts(cpp_configuration, source_file, label))
    return result

def _copts_from_options(language, cpp_configuration, extension):
    result = []
    result.extend(cpp_configuration.copts)
    if extension in extensions.C_SOURCE:
        result.extend(cpp_configuration.conlyopts)
    if extension in _SOURCE_TYPES_FOR_CXXOPTS:
        result.extend(cpp_configuration.cxxopts)
    if extension in [extensions.OBJC_SOURCE, extensions.OBJCPP_SOURCE] or (
        language == "objc" and extension in extensions.CC_HEADER
    ):
        result.extend(cpp_configuration.objccopts)
    return result
