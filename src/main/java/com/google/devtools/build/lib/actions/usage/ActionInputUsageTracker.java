// Copyright 2014 The Bazel Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package com.google.devtools.build.lib.actions.usage;

import com.google.devtools.build.lib.actions.*;
import com.google.devtools.build.lib.buildtool.BuildRequestOptions.ActionInputUsageTrackerMode;
import com.google.devtools.build.lib.vfs.Path;
import com.google.devtools.build.lib.view.proto.Deps;

import javax.annotation.Nullable;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import static com.google.common.base.Preconditions.checkState;
import static com.google.devtools.build.lib.actions.usage.Utils.getHashFromJarEntry;
import static com.google.devtools.build.lib.actions.usage.Utils.getJDepsOutput;

/**
 * Class responsible for removing irrelevant inputs used for an action cache key computation. The goal here is to
 * achieve incremental compilation avoidance by dismissing unused input. This way, any change to these input will
 * cause computed action cache key to remain unchanged, leading to a local cache hit / skip of action re-execution.
 * The list of unused input is generated by the action itself, during previous action execution, and stored to disk
 * among action outputs (typically .jdeps file for Java/Kotlin compilation action).
 * <p>
 * Action can also generate more granular usage data through used "classes". For these, changes not classes that are
 * not specified as 'used' will similarly be removed from action cache key computation.
 * <p>
 * Note of software design : instead of modifying Action/AbstractAction class itself (similarly to input discovery
 * feature), we use composition via this separate class to keep the logic separated, and facilitate merging changes
 * from Bazel master branch.
 */
public class ActionInputUsageTracker {

    /**
     * Internal class tracking usage info for a given action.
     */
    class UsageInfo {
        private Set<String> unusedArtifactPaths;
        private Map<String, Set<ClassUsageInfo>> usedClassesMap;

        UsageInfo(Set<String> unusedArtifactPaths, Map<String, Set<ClassUsageInfo>> usedClassesMap) {
            this.unusedArtifactPaths = unusedArtifactPaths;
            this.usedClassesMap = usedClassesMap;
        }
    }

    /**
     * For now, only JVM-based rules tracks usage / provide .jdeps output artifact.
     */
    private static final Set<String> SUPPORTED_DEPENDENCY_TRACKING_MNEMONICS = Set.of("Javac", "KotlinCompile");
    private static final Set<String> SUPPORTED_CLASS_TRACKING_MNEMONICS = Set.of("Javac", "KotlinCompile");

    private static final boolean VERBOSE_MODE = true;

    private final ArtifactPathResolver pathResolver;
    private final ActionInputUsageTrackerMode trackerMode;
    private final Map<String, UsageInfo> trackerInfoMap;

    public ActionInputUsageTracker(ArtifactPathResolver pathResolver, ActionInputUsageTrackerMode trackerMode) {
        this.pathResolver = pathResolver;
        this.trackerMode = trackerMode;
        this.trackerInfoMap = new HashMap<>();
    }

    /**
     * Whether action input tracking is enabled or not.
     */
    public boolean enabled() {
        return this.trackerMode != ActionInputUsageTrackerMode.DISABLED;
    }

    /**
     * Whether action supports input tracking.
     */
    public boolean supportsInputTracking(Action action) {
        return enabled() &&
                action.getOwner().getLabel() != null &&
                action.getOwner().getLabel().getRepository().isMain() &&
                getJDepsOutput(action) != null &&
                SUPPORTED_DEPENDENCY_TRACKING_MNEMONICS.contains(action.getMnemonic());
    }

    /**
     * Whether action supports classes input tracking.
     */
    public boolean supportsClassTracking(Action action) {
        return this.trackerMode == ActionInputUsageTrackerMode.UNUSED_CLASSES &&
                action.getOwner().getLabel() != null &&
                action.getOwner().getLabel().getRepository().isMain() &&
                getJDepsOutput(action) != null &&
                SUPPORTED_CLASS_TRACKING_MNEMONICS.contains(action.getMnemonic());
    }

    /**
     * Refresh internal input tracking info from action .jdeps file.
     */
    public void refreshInputTrackingInfo(Action action) {
        if (!enabled() || !supportsInputTracking(action)) {
            return;
        }

        UsageInfo usageInfo = null;
        try {
            Artifact jdeps = getJDepsOutput(action);
            Path output = pathResolver.toPath(jdeps);
            InputStream input = output.getInputStream();
            Deps.Dependencies deps = Deps.Dependencies.parseFrom(input);
            checkState(deps.getRuleLabel().equals(action.getOwner().getLabel().toString()));

            Set<String> usedPaths = deps.getDependencyList().stream()
                    .filter(d -> d.getKind() == Deps.Dependency.Kind.EXPLICIT || d.getKind() == Deps.Dependency.Kind.IMPLICIT)
                    .map(d -> d.getPath())
                    .collect(Collectors.toCollection(LinkedHashSet::new));
            Set<String> unusedArtifactsPath = action.getInputs().toList().stream()
                    .filter(ActionInputUsageTracker::canArtifactBeUnused)
                    .map(d -> d.getExecPathString())
                    .filter(Predicate.not(usedPaths::contains))
                    .collect(Collectors.toCollection(LinkedHashSet::new));
            Map<String, Set<ClassUsageInfo>> usedClassesMap = deps.getDependencyList().stream()
                    .filter(d -> d.getKind() == Deps.Dependency.Kind.EXPLICIT || d.getKind() == Deps.Dependency.Kind.IMPLICIT)
                    .collect(Collectors.toMap(
                            d -> d.getPath(),
                            d -> d.getUsedClassesList().stream()
                                    .map(ClassUsageInfo::create)
                                    .collect(Collectors.toCollection(LinkedHashSet::new))));

            usageInfo = new UsageInfo(unusedArtifactsPath, usedClassesMap);
        } catch (FileNotFoundException fileNotFoundException) {
            // Silently ignore, this could be a clean build
        } catch (Exception exception) {
            System.err.println("ActionInputUsageTracker: " + getKey(action) + " .jdeps file failed to load, ex=" + exception);
        }

        trackerInfoMap.put(getKey(action), usageInfo);
    }

    /**
     * Get tracking information for the given action and input artifact. If includeDependencyHash is true, we include
     * in the return object classes hash computed from action dependencies themselves (as opposed to the hash of classes
     * that were used in the last action execution, which are always included).
     */
    public TrackingInfo getTrackingInfo(Action action, Artifact artifact, boolean includeDependencyHash) {
        boolean isUnused = supportsInputTracking(action) && isUnusedInput(action, artifact);

        Set<ClassUsageInfo> usedClasses = null;
        if (supportsClassTracking(action) && canArtifactTrackUsedClasses(artifact)) {
            UsageInfo usageInfo = getUsageInfo(action);
            if (usageInfo != null &&
                    usageInfo.usedClassesMap != null &&
                    usageInfo.usedClassesMap.getOrDefault(artifact.getExecPathString(), Collections.emptySet()).size() > 0) {
                usedClasses = usageInfo.usedClassesMap.get(artifact.getExecPathString());
                if (includeDependencyHash) {
                    usedClasses = usedClasses.stream()
                            .map(d -> ClassUsageInfo.create(
                                    d.getFullyQualifiedName(),
                                    d.getInternalPath(),
                                    d.getCompileTimeFileArtifactValue(),
                                    new PreComputedMetadataValue(getHashFromJarEntry(artifact, d.getInternalPath()))))
                            .collect(Collectors.toCollection(LinkedHashSet::new));
                }
            }
        }
        return new TrackingInfo(isUnused, usedClasses);
    }

    /**
     * For debugging purpose.
     */
    public String dump(Action action) {
        int unusedCount = 0;
        int usedCount = 0;
        int usedClasses = 0;
        StringBuilder s = new StringBuilder("ActionInputUsageTracker: " + getKey(action) + " ");
        for (Artifact input : action.getInputs().toList()) {
            if (!canArtifactBeUnused(input)) {
                continue;
            }
            boolean isUnused = supportsInputTracking(action) && isUnusedInput(action, input);
            TrackingInfo trackingInfo = getTrackingInfo(action, input, false);
            if (VERBOSE_MODE) {
                s.append("\n");
                if (isUnused) {
                    s.append("\t(-) " + input.getExecPathString());
                } else {
                    s.append("\t(+) " + input.getExecPathString());
                    if (trackingInfo.tracksUsedClasses()) {
                        s.append(" (" + trackingInfo.getUsedClasses().size() + " tracked classes)");
                    }
                }
            } else {
                if (isUnused) {
                    unusedCount++;
                } else {
                    usedCount++;
                    if (trackingInfo.tracksUsedClasses()) {
                        usedClasses += trackingInfo.getUsedClasses().size();
                    }
                }
            }
        }
        if (!VERBOSE_MODE) {
            String usedClassesStr = supportsClassTracking(action) ? String.format(", %d tracked classes", usedClasses) : "";
            s.append(String.format("[%d used dep, %d unused dep%s]", usedCount, unusedCount, usedClassesStr));
        }

        return s.toString();
    }

    /**
     * Returns the cache key used internally for a given action
     */
    private String getKey(Action action) {
        return action.getOwner().getLabel().toString() + "(" + action.getMnemonic() + ")";
    }

    /**
     * Returns whether input artifact is used by action or not.
     */
    private boolean isUnusedInput(Action action, Artifact input) {
        // Now that jdeps contains additional info (list of used classes/shas), we don't want these to contribute to
        // cache key, as this could cause undesired change of cache key.
        String artifactExecPath = input.getExecPathString();
        if (artifactExecPath.endsWith(".jdeps")) {
            return true;
        }

        if (!supportsInputTracking(action)) {
            return false;
        }

        UsageInfo usageInfo = getUsageInfo(action);
        return usageInfo != null && usageInfo.unusedArtifactPaths.contains(artifactExecPath);
    }

    /**
     * Returns UsageInfo for the given action.
     */
    @Nullable
    private UsageInfo getUsageInfo(Action action) {
        return trackerInfoMap.getOrDefault(getKey(action), null);
    }

    /**
     * Returns whether artifact is eligible to be treated as unused. For JVM, compiling against
     * ABI jars is pre-requisite, therefore we only support ijar/hjar/kotlin ABI artifacts.
     */
    private static boolean canArtifactBeUnused(Artifact artifact) {
        String artifactExecPath = artifact.getExecPathString();
        return artifactExecPath.endsWith("-ijar.jar") ||
                artifactExecPath.endsWith("-hjar.jar") ||
                artifactExecPath.endsWith(".abi.jar");
    }

    /**
     * Returns whether input artifact can track classes or not.
     */
    private static boolean canArtifactTrackUsedClasses(Artifact artifact) {
        String artifactExecPath = artifact.getExecPathString();
        return artifactExecPath.endsWith("-ijar.jar") ||
                artifactExecPath.endsWith("-hjar.jar")  ||
                artifactExecPath.endsWith(".abi.jar");
    }
}
