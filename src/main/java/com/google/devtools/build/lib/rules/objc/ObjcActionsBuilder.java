// Copyright 2014 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.google.devtools.build.lib.rules.objc;

import static com.google.devtools.build.lib.rules.objc.IosSdkCommands.BIN_DIR;
import static com.google.devtools.build.lib.rules.objc.IosSdkCommands.MINIMUM_OS_VERSION;
import static com.google.devtools.build.lib.rules.objc.IosSdkCommands.TARGET_DEVICE_FAMILIES;
import static com.google.devtools.build.lib.rules.objc.ObjcActionsBuilder.CLANG;
import static com.google.devtools.build.lib.rules.objc.ObjcActionsBuilder.CLANG_PLUSPLUS;
import static com.google.devtools.build.lib.rules.objc.ObjcProvider.ASSET_CATALOG;
import static com.google.devtools.build.lib.rules.objc.ObjcProvider.FRAMEWORK_DIR;
import static com.google.devtools.build.lib.rules.objc.ObjcProvider.FRAMEWORK_FILE;
import static com.google.devtools.build.lib.rules.objc.ObjcProvider.Flag.USES_CPP;
import static com.google.devtools.build.lib.rules.objc.ObjcProvider.HEADER;
import static com.google.devtools.build.lib.rules.objc.ObjcProvider.IMPORTED_LIBRARY;
import static com.google.devtools.build.lib.rules.objc.ObjcProvider.INCLUDE;
import static com.google.devtools.build.lib.rules.objc.ObjcProvider.LIBRARY;
import static com.google.devtools.build.lib.rules.objc.ObjcProvider.SDK_DYLIB;
import static com.google.devtools.build.lib.rules.objc.ObjcProvider.SDK_FRAMEWORK;
import static com.google.devtools.build.lib.rules.objc.ObjcProvider.XCASSETS_DIR;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Iterables;
import com.google.devtools.build.lib.actions.Action;
import com.google.devtools.build.lib.actions.ActionRegistry;
import com.google.devtools.build.lib.actions.Artifact;
import com.google.devtools.build.lib.vfs.PathFragment;
import com.google.devtools.build.lib.view.RuleConfiguredTarget.Mode;
import com.google.devtools.build.lib.view.RuleContext;
import com.google.devtools.build.lib.view.actions.ActionConstructionContext;
import com.google.devtools.build.lib.view.actions.CommandLine;
import com.google.devtools.build.lib.view.actions.SpawnAction;
import com.google.devtools.build.xcode.common.TargetDeviceFamily;
import com.google.devtools.build.xcode.util.Interspersing;
import com.google.devtools.build.xcode.xcodegen.proto.XcodeGenProtos;
import com.google.devtools.build.xcode.xcodegen.proto.XcodeGenProtos.TargetControl;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

/**
 * Utility code for creating actions used by Objective-C rules.
 * <p>
 * This is a static-only class. If you make this into a reference class, the {@link CommandLine}
 * anonymous inner classes must become static inner classes. The garbage collector will not collect
 * {@code ObjcActionsBuilder} as long as the anonymous {@link CommandLine} instances are alive.
 * <p>
 * TODO(bazel-team): Make this a non-static class that contains fields corresponding to often-passed
 * arguments. As the Javadoc above suggests, this will require making the anonymous inner class
 * static named classes.
 */
public class ObjcActionsBuilder {
  private ObjcActionsBuilder() {
    throw new UnsupportedOperationException("static-only");
  }

  /**
   * Creates a {@code SpawnAction.Builder} that does not get registered automatically when created.
   * This is to make the {@code SpawnAction}s generated by this class consistent with actions of
   * other types.
   */
  private static SpawnAction.Builder spawnActionBuilder(ActionConstructionContext context) {
    return new SpawnAction.Builder(context).setRegisterSpawnAction(false);
  }

  private static SpawnAction.Builder spawnOnDarwinActionBuilder(ActionConstructionContext context) {
    return spawnActionBuilder(context)
        .setExecutionInfo(ImmutableMap.of(ExecutionRequirements.REQUIRES_DARWIN, ""));
  }

  static final PathFragment JAVA = new PathFragment("/usr/bin/java");
  static final PathFragment CLANG = new PathFragment(BIN_DIR + "/clang");
  static final PathFragment CLANG_PLUSPLUS = new PathFragment(BIN_DIR + "/clang++");
  static final PathFragment LIBTOOL = new PathFragment(BIN_DIR + "/libtool");
  static final PathFragment IBTOOL = new PathFragment("/usr/bin/ibtool");
  static final PathFragment DSYMUTIL = new PathFragment(BIN_DIR + "/dsymutil");

  // TODO(bazel-team): Reference a rule target rather than a jar file when Darwin runfiles work
  // better.
  private static SpawnAction.Builder spawnJavaOnDarwinActionBuilder(
      ActionConstructionContext context, Artifact deployJarArtifact) {
    return spawnOnDarwinActionBuilder(context)
        .setExecutable(JAVA)
        .addExecutableArguments("-jar", deployJarArtifact.getExecPathString())
        .addInput(deployJarArtifact);
  }

  private static SpawnAction.Builder spawnJavaOnDarwinActionBuilder(
      RuleContext ruleContext, String deployJarAttribute) {
    return spawnJavaOnDarwinActionBuilder(ruleContext,
        ruleContext.getPrerequisiteArtifact(deployJarAttribute, Mode.HOST));
  }

  private static Action compileAction(final RuleContext ruleContext, final Artifact sourceFile,
      final Optional<Artifact> pchFile, final ObjcProvider provider,
      final Iterable<String> otherFlags, final OptionsProvider optionsProvider) {
    final Artifact objFile = ObjcRuleClasses.objFile(ruleContext, sourceFile);
    return spawnOnDarwinActionBuilder(ruleContext)
        .setMnemonic("Compile")
        .setExecutable(CLANG)
        .setCommandLine(new CommandLine() {
          @Override
          public Iterable<String> arguments() {
            return new ImmutableList.Builder<String>()
                .addAll(IosSdkCommands.compileArgsForClang(objcConfiguration(ruleContext)))
                .addAll(IosSdkCommands.commonLinkAndCompileArgsForClang(
                    provider, objcConfiguration(ruleContext)))
                .addAll(Interspersing.beforeEach(
                    "-iquote",
                    PathFragment.safePathStrings(
                        ObjcCommon.userHeaderSearchPaths(ruleContext.getConfiguration()))))
                .addAll(Interspersing.beforeEach(
                    "-include", Artifact.asExecPaths(pchFile.asSet())))
                .addAll(Interspersing.beforeEach(
                    "-I", PathFragment.safePathStrings(provider.get(INCLUDE))))
                .addAll(otherFlags)
                .addAll(optionsProvider.getCopts())
                .add("-c").add(sourceFile.getExecPathString())
                .add("-o").add(objFile.getExecPathString())
                .build();
          }
        })
        .addInput(sourceFile)
        .addOutput(objFile)
        .addTransitiveInputs(provider.get(HEADER))
        .addTransitiveInputs(provider.get(FRAMEWORK_FILE))
        .addInputs(pchFile.asSet())
        .build();
  }

  private static final ImmutableList<String> ARC_ARGS = ImmutableList.of("-fobjc-arc");
  private static final ImmutableList<String> NON_ARC_ARGS = ImmutableList.of("-fno-objc-arc");

  /**
   * Creates actions to compile each source file individually, and link all the compiled object
   * files into a single archive library.
   * @return the {@code Action}s that were created
   */
  static Iterable<Action> compileAndLinkActions(RuleContext ruleContext,
      CompilationArtifacts compilationArtifacts, ObjcProvider provider,
      OptionsProvider optionsProvider) {
    ImmutableList.Builder<Action> result = new ImmutableList.Builder<>();
    for (Artifact sourceFile : compilationArtifacts.getSrcs()) {
      result.add(compileAction(ruleContext, sourceFile, compilationArtifacts.getPchFile(),
          provider, ARC_ARGS, optionsProvider));
    }
    for (Artifact nonArcSourceFile : compilationArtifacts.getNonArcSrcs()) {
      result.add(compileAction(ruleContext, nonArcSourceFile, compilationArtifacts.getPchFile(),
          provider, NON_ARC_ARGS, optionsProvider));
    }

    for (final Artifact archive : compilationArtifacts.getArchive().asSet()) {
      final Iterable<Artifact> objFiles = ImmutableList.copyOf(
          ObjcRuleClasses.objFiles(
              ruleContext,
              Iterables.concat(
                  compilationArtifacts.getSrcs(),
                  compilationArtifacts.getNonArcSrcs())));
      final ObjcConfiguration configuration = objcConfiguration(ruleContext);

      result.add(spawnOnDarwinActionBuilder(ruleContext)
          .setMnemonic("Link")
          .setExecutable(LIBTOOL)
          .setCommandLine(new CommandLine() {
              @Override
              public Iterable<String> arguments() {
                return new ImmutableList.Builder<String>()
                    .add("-static")
                    .addAll(Artifact.toExecPaths(objFiles))
                    .add("-arch_only").add(configuration.getIosCpu())
                    .add("-syslibroot").add(IosSdkCommands.sdkDir(configuration))
                    .add("-o").add(archive.getExecPathString())
                    .build();
              }
            })
          .addInputs(objFiles)
          .addOutput(archive)
          .build());
    }

    return result.build();
  }

  /**
   * Registers all actions in a collection.
   */
  static void registerAll(ActionRegistry actionRegistry, Iterable<? extends Action> actions) {
    for (Action action : actions) {
      actionRegistry.registerAction(action);
    }
  }

  /**
   * Generates actions needed to create an Xcode project file.
   */
  static Iterable<Action> xcodegenActions(RuleContext ruleContext,
      Iterable<TargetControl> targets) {
    Artifact pbxproj = ObjcRuleClasses.pbxprojArtifact(ruleContext);
    XcodeGenProtos.Control xcodegenControl = XcodeGenProtos.Control.newBuilder()
        .setPbxproj(pbxproj.getExecPathString())
        .addAllTarget(targets)
        .build();
    Artifact controlFile = ObjcRuleClasses.pbxprojControlArtifact(ruleContext);
    return ImmutableList.<Action>of(
        new WriteXcodeGenControlFileAction(
            ruleContext.getActionOwner(), controlFile, xcodegenControl),
        spawnActionBuilder(ruleContext)
            .setMnemonic("Generate project")
            .setExecutable(ruleContext.getExecutablePrerequisite("$xcodegen", Mode.HOST))
            .addArgument("--control")
            .addInputArgument(controlFile)
            .addOutput(pbxproj)
            .build());
  }

  /**
   * Creates actions to convert all files specified by the strings attribute into binary format.
   */
  static Iterable<Action> convertStringsActions(RuleContext ruleContext) {
    ImmutableList.Builder<Action> result = new ImmutableList.Builder<>();
    for (CompiledResourceFile stringsFile :
        CompiledResourceFile.stringsFilesFromRule(ruleContext)) {
      final Artifact original = stringsFile.getOriginal();
      final Artifact bundled = stringsFile.getBundled().getBundled();
      result.add(spawnActionBuilder(ruleContext)
          .setMnemonic("Convert plist to binary")
          .setExecutable(ruleContext.getExecutablePrerequisite("$plmerge", Mode.HOST))
          .setCommandLine(new CommandLine() {
            @Override
            public Iterable<String> arguments() {
              return ImmutableList.of("--source_file", original.getExecPathString(),
                  "--out_file", bundled.getExecPathString());
            }
          })
          .addInput(original)
          .addOutput(bundled)
          .build());
    }
    return result.build();
  }

  /**
   * Creates actions to convert all files specified by the xibs attribute into nib format.
   */
  static Iterable<Action> convertXibsActions(RuleContext ruleContext) {
    ImmutableList.Builder<Action> result = new ImmutableList.Builder<>();
    for (CompiledResourceFile xibFile : CompiledResourceFile.xibFilesFromRule(ruleContext)) {
      final Artifact bundled = xibFile.getBundled().getBundled();
      final Artifact original = xibFile.getOriginal();
      result.add(spawnOnDarwinActionBuilder(ruleContext)
          .setMnemonic("Compile xib")
          .setExecutable(IBTOOL)
          .setCommandLine(new CommandLine() {
            @Override
            public Iterable<String> arguments() {
              return ImmutableList.of(
                  "--minimum-deployment-target", MINIMUM_OS_VERSION,
                  "--compile", bundled.getExecPathString(),
                  original.getExecPathString());
            }
          })
          .addOutput(bundled)
          .addInput(original)
          .build());
    }
    return result.build();
  }

  static final class ExtraActoolArgs extends IterableWrapper<String> {
    ExtraActoolArgs(Iterable<String> args) {
      super(args);
    }

    ExtraActoolArgs(String... args) {
      super(args);
    }
  }

  static Action actoolzipAction(ActionConstructionContext context,
      final ObjcConfiguration objcConfiguration, Artifact actoolzipDeploy,
      final ObjcProvider provider, final Artifact actoolzipOutput,
      final ExtraActoolArgs extraActoolArgs) {
    // TODO(bazel-team): Do not use the deploy jar explicitly here. There is currently a bug where
    // we cannot .setExecutable({java_binary target}) and set REQUIRES_DARWIN in the execution info.
    // Note that below we set the archive root to the empty string. This means that the generated
    // zip file will be rooted at the bundle root, and we have to prepend the bundle root to each
    // entry when merging it with the final .ipa file.
    return spawnJavaOnDarwinActionBuilder(context, actoolzipDeploy)
        .setMnemonic("Compile asset catalogs")
        .addTransitiveInputs(provider.get(ASSET_CATALOG))
        .addOutput(actoolzipOutput)
        .setCommandLine(new CommandLine() {
          @Override
          public Iterable<String> arguments() {
            ImmutableList.Builder<String> args = new ImmutableList.Builder<String>()
                // The next three arguments are positional, i.e. they don't have flags before them.
                .add(actoolzipOutput.getExecPathString())
                .add("") // archive root
                .add(IosSdkCommands.ACTOOL_PATH)
                .add("--platform")
                .add(objcConfiguration.getPlatform().getLowerCaseNameInPlist())
                .add("--minimum-deployment-target").add(MINIMUM_OS_VERSION);
            for (TargetDeviceFamily targetDeviceFamily : TARGET_DEVICE_FAMILIES) {
              args.add("--target-device").add(targetDeviceFamily.name().toLowerCase(Locale.US));
            }
            return args
                .addAll(PathFragment.safePathStrings(provider.get(XCASSETS_DIR)))
                .addAll(extraActoolArgs)
                .build();
          }
        })
        .build();
  }

  @VisibleForTesting
  static Iterable<String> commonMomczipArguments(ObjcConfiguration configuration) {
    return ImmutableList.of(
        "-XD_MOMC_SDKROOT=" + IosSdkCommands.sdkDir(configuration),
        "-XD_MOMC_IOS_TARGET_VERSION=" + IosSdkCommands.MINIMUM_OS_VERSION,
        "-MOMC_PLATFORMS", configuration.getPlatform().getLowerCaseNameInPlist(),
        "-XD_MOMC_TARGET_VERSION=10.6");
  }

  static Iterable<Action> momczipActions(RuleContext ruleContext) {
    final ObjcConfiguration configuration = objcConfiguration(ruleContext);
    ImmutableList.Builder<Action> result = new ImmutableList.Builder<>();
    for (Xcdatamodel datamodel : Xcdatamodels.xcdatamodels(ruleContext)) {
      final Artifact outputZip = datamodel.getOutputZip();
      final String archiveRoot = datamodel.archiveRootForMomczip();
      final String container = datamodel.getContainer().getSafePathString();
      result.add(spawnJavaOnDarwinActionBuilder(ruleContext, "$momczip_deploy")
          .addOutput(outputZip)
          .addInputs(datamodel.getInputs())
          .setCommandLine(new CommandLine() {
            @Override
            public Iterable<String> arguments() {
              return new ImmutableList.Builder<String>()
                  .add(outputZip.getExecPathString())
                  .add(archiveRoot)
                  .add(IosSdkCommands.momcPath(configuration))
                  .addAll(commonMomczipArguments(configuration))
                  .add(container)
                  .build();
            }
          })
          .build());
    }
    return result.build();
  }

  private static final String FRAMEWORK_SUFFIX = ".framework";

  /**
   * All framework names to pass to the linker using {@code -framework} flags. For a framework in
   * the directory foo/bar.framework, the name is "bar". Each framework is found without using the
   * full path by means of the framework search paths. The search paths are added by
   * {@link IosSdkCommands#commonLinkAndCompileArgsForClang(ObjcProvider, ObjcConfiguration)}).
   *
   * <p>It's awful that we can't pass the full path to the framework and avoid framework search
   * paths, but this is imposed on us by clang. clang does not support passing the full path to the
   * framework, so Bazel cannot do it either.
   */
  private static Iterable<String> frameworkNames(ObjcProvider provider) {
    List<String> names = new ArrayList<>();
    Iterables.addAll(names, SdkFramework.names(provider.get(SDK_FRAMEWORK)));
    for (PathFragment frameworkDir : provider.get(FRAMEWORK_DIR)) {
      String segment = frameworkDir.getBaseName();
      Preconditions.checkState(segment.endsWith(FRAMEWORK_SUFFIX),
          "expect %s to end with %s, but it does not", segment, FRAMEWORK_SUFFIX);
      names.add(segment.substring(0, segment.length() - FRAMEWORK_SUFFIX.length()));
    }
    return names;
  }

  static final class ExtraLinkArgs extends IterableWrapper<String> {
    ExtraLinkArgs(Iterable<String> args) {
      super(args);
    }

    ExtraLinkArgs(String... args) {
      super(args);
    }
  }

  private static final class LinkCommandLine extends CommandLine {
    private final ObjcProvider objcProvider;
    private final ObjcConfiguration objcConfiguration;
    private final Artifact linkedBinary;
    private final ExtraLinkArgs extraLinkArgs;

    LinkCommandLine(ObjcConfiguration objcConfiguration, ExtraLinkArgs extraLinkArgs,
        ObjcProvider objcProvider, Artifact linkedBinary) {
      this.objcConfiguration = Preconditions.checkNotNull(objcConfiguration);
      this.extraLinkArgs = Preconditions.checkNotNull(extraLinkArgs);
      this.objcProvider = Preconditions.checkNotNull(objcProvider);
      this.linkedBinary = Preconditions.checkNotNull(linkedBinary);
    }

    Iterable<String> dylibPaths() {
      ImmutableList.Builder<String> args = new ImmutableList.Builder<>();
      for (String dylib : objcProvider.get(SDK_DYLIB)) {
        args.add(String.format(
            "%s/usr/lib/%s.dylib", IosSdkCommands.sdkDir(objcConfiguration), dylib));
      }
      return args.build();
    }

    @Override
    public Iterable<String> arguments() {
      return new ImmutableList.Builder<String>()
          .addAll(objcProvider.is(USES_CPP)
              ? ImmutableList.of("-stdlib=libc++") : ImmutableList.<String>of())
          .addAll(IosSdkCommands.commonLinkAndCompileArgsForClang(objcProvider, objcConfiguration))
          .add("-Xlinker", "-objc_abi_version")
          .add("-Xlinker", "2")
          .add("-fobjc-link-runtime")
          .add("-ObjC")
          .addAll(Interspersing.beforeEach("-framework", frameworkNames(objcProvider)))
          .add("-o", linkedBinary.getExecPathString())
          .addAll(Artifact.toExecPaths(objcProvider.get(LIBRARY)))
          .addAll(Artifact.toExecPaths(objcProvider.get(IMPORTED_LIBRARY)))
          .addAll(dylibPaths())
          .addAll(extraLinkArgs)
          .build();
    }
  }

  /**
   * Generates an action to link a binary.
   */
  static Action linkAction(ActionConstructionContext context, Artifact linkedBinary,
      ObjcConfiguration objcConfiguration, ObjcProvider objcProvider,
      ExtraLinkArgs extraLinkArgs) {
    return spawnOnDarwinActionBuilder(context)
        .setMnemonic("Link")
        .setExecutable(objcProvider.is(USES_CPP) ? CLANG_PLUSPLUS : CLANG)
        .setCommandLine(
            new LinkCommandLine(objcConfiguration, extraLinkArgs, objcProvider, linkedBinary))
        .addOutput(linkedBinary)
        .addTransitiveInputs(objcProvider.get(LIBRARY))
        .addTransitiveInputs(objcProvider.get(IMPORTED_LIBRARY))
        .addTransitiveInputs(objcProvider.get(FRAMEWORK_FILE))
        .build();
  }

  /**
   * Creates actions that are common to objc_binary and objc_library rules.
   */
  static Iterable<Action> baseActions(RuleContext ruleContext,
      Optional<CompilationArtifacts> maybeCompilationArtifacts, ObjcProvider provider,
      XcodeProvider xcodeProvider, OptionsProvider optionsProvider) {
    ImmutableList.Builder<Action> actions = new ImmutableList.Builder<Action>()
        .addAll(xcodegenActions(ruleContext, xcodeProvider.getTargets()))
        .addAll(convertStringsActions(ruleContext))
        .addAll(convertXibsActions(ruleContext))
        .addAll(momczipActions(ruleContext));
    for (CompilationArtifacts compilationArtifacts : maybeCompilationArtifacts.asSet()) {
      actions.addAll(
          compileAndLinkActions(ruleContext, compilationArtifacts, provider, optionsProvider));
    }
    return actions.build();
  }

  static ObjcConfiguration objcConfiguration(RuleContext ruleContext) {
    return ruleContext.getConfiguration().getFragment(ObjcConfiguration.class);
  }
}
