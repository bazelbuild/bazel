// Copyright 2021 The Bazel Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.google.devtools.build.lib.bazel.bzlmod;

import com.google.auto.value.AutoValue;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.devtools.build.docgen.annot.DocCategory;
import com.google.devtools.build.lib.cmdline.RepositoryName;
import java.util.LinkedHashMap;
import java.util.Map;
import javax.annotation.Nullable;
import net.starlark.java.annot.StarlarkBuiltin;
import net.starlark.java.eval.Dict;
import net.starlark.java.eval.EvalException;
import net.starlark.java.eval.Sequence;
import net.starlark.java.eval.Starlark;
import net.starlark.java.eval.StarlarkList;
import net.starlark.java.eval.StarlarkValue;

/** The Starlark object optionally returned by a module extension's implementation function. */
@StarlarkBuiltin(
    name = "extension_metadata",
    category = DocCategory.BUILTIN,
    doc =
        "Return values of this type from a module extension's implementation function to "
            + "provide metadata about the repositories generated by the extension to Bazel.")
@AutoValue
public abstract class ModuleExtensionMetadata implements StarlarkValue {

  static final ModuleExtensionMetadata DEFAULT =
      create(
          /* explicitRootModuleDirectDeps= */ null,
          /* explicitRootModuleDirectDevDeps= */ null,
          UseAllRepos.NO,
          /* reproducible= */ false,
          /* facts= */ Facts.EMPTY);

  static final ModuleExtensionMetadata REPRODUCIBLE =
      create(
          /* explicitRootModuleDirectDeps= */ null,
          /* explicitRootModuleDirectDevDeps= */ null,
          UseAllRepos.NO,
          /* reproducible= */ true,
          /* facts= */ Facts.EMPTY);

  @Nullable
  abstract ImmutableMap<String, String> getExplicitRootModuleDirectDeps();

  @Nullable
  abstract ImmutableMap<String, String> getExplicitRootModuleDirectDevDeps();

  abstract UseAllRepos getUseAllRepos();

  abstract boolean getReproducible();

  abstract Facts getFacts();

  private static ModuleExtensionMetadata create(
      @Nullable Map<String, String> explicitRootModuleDirectDeps,
      @Nullable Map<String, String> explicitRootModuleDirectDevDeps,
      UseAllRepos useAllRepos,
      boolean reproducible,
      Facts facts) {
    return new AutoValue_ModuleExtensionMetadata(
        explicitRootModuleDirectDeps != null
            ? ImmutableMap.copyOf(explicitRootModuleDirectDeps)
            : null,
        explicitRootModuleDirectDevDeps != null
            ? ImmutableMap.copyOf(explicitRootModuleDirectDevDeps)
            : null,
        useAllRepos,
        reproducible,
        facts);
  }

  static ModuleExtensionMetadata create(
      Object rootModuleDirectDepsUnchecked,
      Object rootModuleDirectDevDepsUnchecked,
      boolean reproducible,
      Dict<String, Object> factsObj)
      throws EvalException {
    var facts = Facts.validateAndCreate(factsObj);

    if (rootModuleDirectDepsUnchecked == Starlark.NONE
        && rootModuleDirectDevDepsUnchecked == Starlark.NONE) {
      return create(null, null, UseAllRepos.NO, reproducible, facts);
    }

    // When root_module_direct_deps = "all", accept both root_module_direct_dev_deps = None and
    // root_module_direct_dev_deps = [], but not root_module_direct_dev_deps = ["some_repo"].
    if (rootModuleDirectDepsUnchecked.equals("all")
        && rootModuleDirectDevDepsUnchecked.equals(StarlarkList.immutableOf())) {
      return create(null, null, UseAllRepos.REGULAR, reproducible, facts);
    }

    if (rootModuleDirectDevDepsUnchecked.equals("all")
        && rootModuleDirectDepsUnchecked.equals(StarlarkList.immutableOf())) {
      return create(null, null, UseAllRepos.DEV, reproducible, facts);
    }

    if (rootModuleDirectDepsUnchecked.equals("all")
        || rootModuleDirectDevDepsUnchecked.equals("all")) {
      throw Starlark.errorf(
          "if one of root_module_direct_deps and root_module_direct_dev_deps is "
              + "\"all\", the other must be an empty list");
    }

    if (rootModuleDirectDepsUnchecked instanceof String
        || rootModuleDirectDevDepsUnchecked instanceof String) {
      throw Starlark.errorf(
          "root_module_direct_deps and root_module_direct_dev_deps must be "
              + "None, \"all\", a list of strings, or a dict of strings");
    }
    if ((rootModuleDirectDepsUnchecked == Starlark.NONE)
        != (rootModuleDirectDevDepsUnchecked == Starlark.NONE)) {
      throw Starlark.errorf(
          "root_module_direct_deps and root_module_direct_dev_deps must both be "
              + "specified or both be unspecified");
    }

    Map<String, String> explicitRootModuleDirectDeps =
        parseRootModuleDirectDeps(rootModuleDirectDepsUnchecked, "root_module_direct_deps");
    Map<String, String> explicitRootModuleDirectDevDeps =
        parseRootModuleDirectDeps(rootModuleDirectDevDepsUnchecked, "root_module_direct_dev_deps");

    // Check for overlapping module-local names between deps and dev_deps
    for (String moduleLocalName : explicitRootModuleDirectDevDeps.keySet()) {
      if (explicitRootModuleDirectDeps.containsKey(moduleLocalName)) {
        throw Starlark.errorf(
            "in root_module_direct_dev_deps: module-local name '%s' is also in "
                + "root_module_direct_deps",
            moduleLocalName);
      }
    }

    // Check for overlapping extension names between deps and dev_deps
    // Pre-collect extension names into a Set for O(1) lookup instead of O(N) containsValue()
    var extensionNamesInDeps = ImmutableSet.copyOf(explicitRootModuleDirectDeps.values());
    for (Map.Entry<String, String> devEntry : explicitRootModuleDirectDevDeps.entrySet()) {
      String extensionName = devEntry.getValue();
      if (extensionNamesInDeps.contains(extensionName)) {
        throw Starlark.errorf(
            "in root_module_direct_dev_deps: extension name '%s' is also in "
                + "root_module_direct_deps",
            extensionName);
      }
    }

    return create(
        explicitRootModuleDirectDeps,
        explicitRootModuleDirectDevDeps,
        UseAllRepos.NO,
        reproducible,
        facts);
  }

  /**
   * Parses root_module_direct_deps or root_module_direct_dev_deps parameters.
   *
   * <p>Returns a map from module-local name to extension-exported name.
   *
   * <p>For sequences like ["foo", "bar"], creates identity mappings {"foo": "foo", "bar": "bar"}
   *
   * <p>For dicts like {"my_repo": "ext_repo"}, uses the mapping as provided (module-local ->
   * extension-exported)
   */
  private static Map<String, String> parseRootModuleDirectDeps(Object unchecked, String paramName)
      throws EvalException {
    Map<String, String> result = new LinkedHashMap<>();

    if (unchecked instanceof Sequence) {
      // Handle sequence of strings - create identity mappings (key -> key)
      Sequence<String> sequence = Sequence.cast(unchecked, String.class, paramName);
      for (String repoName : sequence) {
        try {
          RepositoryName.validateUserProvidedRepoName(repoName);
        } catch (EvalException e) {
          throw Starlark.errorf("in %s: %s", paramName, e.getMessage());
        }
        if (result.containsKey(repoName)) {
          throw Starlark.errorf("in %s: duplicate entry '%s'", paramName, repoName);
        }
        result.put(repoName, repoName);
      }
    } else if (unchecked instanceof Dict) {
      // Handle dict of strings to strings
      // Key = module-local name, Value = extension-exported name
      Dict<String, String> dict = Dict.cast(unchecked, String.class, String.class, paramName);
      // Track extension names to detect duplicates
      var extensionNames = new java.util.HashSet<String>(dict.size());
      for (Map.Entry<String, String> entry : dict.entrySet()) {
        String moduleLocalName = entry.getKey();
        String extensionName = entry.getValue();

        try {
          RepositoryName.validateUserProvidedRepoName(moduleLocalName);
        } catch (EvalException e) {
          throw Starlark.errorf(
              "in %s: invalid module-local name '%s': %s", paramName, moduleLocalName, e.getMessage());
        }

        try {
          RepositoryName.validateUserProvidedRepoName(extensionName);
        } catch (EvalException e) {
          throw Starlark.errorf(
              "in %s: invalid extension name '%s': %s", paramName, extensionName, e.getMessage());
        }

        if (result.containsKey(moduleLocalName)) {
          throw Starlark.errorf("in %s: duplicate module-local name '%s'", paramName, moduleLocalName);
        }
        if (!extensionNames.add(extensionName)) {
          throw Starlark.errorf("in %s: duplicate extension name '%s'", paramName, extensionName);
        }
        result.put(moduleLocalName, extensionName);
      }
    } else {
      throw Starlark.errorf(
          "%s must be a list of strings or a dict of strings to strings", paramName);
    }

    return result;
  }

  enum UseAllRepos {
    NO,
    REGULAR,
    DEV,
  }
}
