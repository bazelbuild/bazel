def _generate_node_modules(rctx, dir_):
    rctx.file()

def _generate_fine_grained_node_modules(rctx):
    print("--fetch--")
    package_json_path = rctx.path(rctx.attr.package_json)

    rctx.file(
        "script.sh",
        """
root_dir="$1/node_modules"
mkdir $root_dir
mkdir $root_dir/example-module
cat > "$root_dir/example-module/package.json" <<EOF
{
  "license": "MIT",
  "main": "example-module.js",
  "name": "example-module",
  "repository": {
    "type": "git",
    "url": "aaa"
  },
  "version": "0.2.0"
}
EOF
echo "ok"
""",
        executable = True,
    )
    cmd(rctx, "echo $DEBUG_ID > debug_id && echo 'ok'")
    result = cmd(rctx, "./script.sh " + str(package_json_path.dirname))

    node_modules_root = rctx.path(str(package_json_path) + "/../node_modules")
    build_file_lines = []
    for path_ in node_modules_root.readdir():
        name = path_.basename
        rctx.symlink(path_, rctx.path(name))
        build_file_lines += ["""filegroup(name = "{name}", srcs = glob(["{name}/**"]), visibility = ["//visibility:public"])""".format(name = name)]

    rctx.file("BUILD", "\n".join(build_file_lines))

generate_fine_grained_node_modules = repository_rule(
    implementation = _generate_fine_grained_node_modules,
    attrs = {
        "package_json": attr.label(),
        "_generate_node_modules": attr.label(
            default = "generate_node_modules.py",
            allow_single_file = True,
        ),
    },
)

def cmd(
        repository_ctx,
        command,
        environment = None):
    """Execute a command, return stdout if succeed and throw an error if it fails. Doesn't escape the result!"""
    if environment:
        result = repository_ctx.execute(["bash", "-c", command], environment = environment)
    else:
        result = repository_ctx.execute(["bash", "-c", command])
    if result.return_code != 0:
        fail("non-zero exit code: %d, command %s, stderr: (%s)" % (
            result.return_code,
            command,
            result.stderr,
        ))
    stripped_stdout = result.stdout.strip()
    if not stripped_stdout:
        fail(
            "empty output from command %s, stderr: (%s)" % (command, result.stderr),
        )
    return stripped_stdout
